/*
 **Purpose: Defines function responsible for bootstrapping connections and vline objects that allow other application c
 * components to interact with the vline service api.
 */
define(['angular', 'Logger', 'vline', './module'], function (ng, Logger, vline, controllersModule) {

    'use strict';

    Logger.debug('Registering controller CustomerServiceController');

    controllersModule.controller('CustomerServiceController', ['$scope', 'WebRtcClientService',
        'CustomerServiceConfiguration', 'RemotePersonService', function ($scope, WebRtcClientService, appConfig, RemotePersonService) {


            /**
             * @type {WebRtcClientService}
             */
            $scope.WebRtcClientService = WebRtcClientService;

            /**
             *
             * @type {RemotePersonService}
             */
            $scope.RemotePersonService = RemotePersonService;

            $scope.WebRtcClient = WebRtcClientService.getClient();
            $scope.WebRtcClientService.setClient($scope.WebRtcClient);

            //Configuration object generated by the server.
            $scope.appConfig = appConfig;

            $scope.webClientConfig = {
                'displayName': appConfig.localEmail,
                'id': appConfig.localEmail
            };

            //Lets us know if we are within the admin or customer view
            $scope.appView = appConfig.viewType;

            $scope.featuresVisible = appConfig.featuresVisible;


            /**
             * If as we are bootstrapping the application we find that we are already logged in
             * log out the user. We want to start the application in the logged out state.
             */
            if ($scope.WebRtcClient.isLoggedIn()) {

                Logger.debug('CustomerServiceController: Already logged in but logging out to start a fresh session.');

                $scope.WebRtcClient.logout().done(function () {

                    Logger.debug('CustomerServiceController: Successfully logged out.');

                }).fail(function () {

                    Logger.debug('CustomerServiceController: Failed to log out.');

                });

            }

            /**
             * Sets the current person to the default within the configuration object.
             * @returns {null | vline.Promise} Returns null if there is no default person, otherwise it returns
             * a promise that returns the default person.
             */
            var initializeDefaultRemotePerson = function () {

                Logger.debug('CustomerServiceController: Initializing default remote person.');

                if ($scope.appConfig.defaultPerson) {
                    return $scope.RemotePersonService.setCurrentRemotePerson($scope.appConfig.defaultPerson);
                }

                //There was not current default remote person
                return null;

            };


            /**
             * When the user logs in we want to store the login session and initialize the default remote person
             * if were within the customer view.
             */
            $scope.WebRtcClient.on('login', function () {

                var logInSession = this.WebRtcClient.getSessions()[0];

                this.WebRtcClientService.setClientLoginSession(logInSession);

                //If we are within the front end view then we have a default person that we should be connecting to
                if ($scope.appView === 'frontend') {
                    initializeDefaultRemotePerson();
                }

            }, $scope);


            /**
             * Gets the remote person from the media session and sets it as the current person within the overall
             * application.
             */
            $scope.setPersonFromMediaSession = function (mediaSession) {

                var mediaSessionPerson = mediaSession.getRemoteStreams()[0].getPerson();

                $scope.RemotePersonService.setCurrentRemotePerson(mediaSessionPerson);

                mediaSessionPerson.release();
            };

            /**
             * Returns an object whose values for if the current configuration contains a feature that
             * requres an active media session to establish a connection with the remote user.
             * @returns {{video: boolean, audio: boolean}}
             */
            function getApplicationMediaConfiguration() {

                var config = {
                    video: false,
                    audio: false
                };

                /**
                 * Can be refactored to use indexOf.
                 */
                for (var i = 0; i < $scope.featuresVisible.length; i++) {

                    if ($scope.featuresVisible[i] === 'video') {

                        config.video = true;
                    }

                    if ($scope.featuresVisible[i] === 'audio') {

                        config.audio = true;
                    }
                }

                return config;

            }


            /**
             * Sends a message to the currently set remote person. This lets the remote person know that someone
             * is online and currently sending them text messages.
             * @returns {vline.Promise | null} Returns a promise of the ping message or null if there was not message
             * to send a ping to.
             */
            $scope.pingRemotePerson = function () {

                var currentRemotePerson = $scope.RemotePersonService.getCurrentRemotePerson();

                return currentRemotePerson ? currentRemotePerson.publishMessage('Remote user attempting to connect.',
                    'x-msg-REMOTE-PERSON-CONNECTION-PING') : null;

            };


            /**
             * Attempts to establish a communication channel with the remote person. If the local user contains
             * a feature that requires a media session to be started, such as video or audio, the we initiate the
             * connection by starting a media session connection on the current person. If  local user contains
             * only a feature that does not require a media session start, then we ping the remote user letting them
             * know that someone is sending messages to their channel.
             */
            $scope.connectAction = function () {

                //Lets us know if our configuration contains a feature that requires a media session start
                var doesConfigContainMediaStreamFeature = $scope.featuresVisible.indexOf('video') !== -1 ||
                    $scope.featuresVisible.indexOf('audio') !== -1;

                if (doesConfigContainMediaStreamFeature) {
                    $scope.startMediaOnCurrentPerson();

                } else if ($scope.featuresVisible.length > 0) {

                    //Let the remote user know that someone is sending messages to them.
                    $scope.pingRemotePerson();
                }

            };

            /**
             * Starts a vline media session on the current application remote person. This means that we
             * attempt to ask the remote person for a video or audio stream.
             */
            $scope.startMediaOnCurrentPerson = function () {

                if ($scope.WebRtcClient.isConnected() && $scope.WebRtcClient.isLoggedIn()) {

                    var person = $scope.RemotePersonService.getCurrentRemotePerson();

                    if (person) {

                        Logger.debug('CustomerServiceController: startMediaOnCurrentPerson: Starting media on current' +
                            ' remote person.');

                        var mediaConfiguration = getApplicationMediaConfiguration();

                        person.startMedia(mediaConfiguration);

                    }

                }

            };

            /**
             * Cuts communication of with the current remote person.
             */
            $scope.stopMediaOnCurrentPerson = function () {

                var person = $scope.RemotePersonService.getCurrentRemotePerson();

                if (person) {

                    Logger.debug('CustomerServiceController: stopMediaOnCurrentPerson: Stopping media on current remote' +
                        ' person.');

                    person.stopMedia();

                    $scope.$broadcast('REMOTE_PERSON_DISCONNECT',person);

                    person.release();

                }


            };


            /**
             * Logout using the currently set client. The function grabs the currently set person and removes it from cache.
             */
            $scope.clientLogout = function () {

                $scope.WebRtcClient.logout().done(function () {

                    Logger.info('CustomerServiceController: clientLogout: Successfully logged out');

                    if (this.RemotePersonService.getCurrentRemotePerson()) {

                        this.RemotePersonService.getCurrentRemotePerson().release();

                        this.RemotePersonService.clearCurrentRemotePerson();
                    }

                }, $scope).fail(function () {
                    Logger.error('CustomerServiceController: clientLogout: Failed to logged out');
                });
            };

            /**
             * The method attempts to login the user into the vline web service. A form is displayed with a user name
             * and password field that allows the user to insert there credentials.
             */
            $scope.login = function () {

                //Using WebRTC API Promises
                $scope.WebRtcClient.login(appConfig.serviceId).done(function (session) {

                    Logger.info('CustomerServiceController: login: Logged in ID: "', session.getLocalPersonId() + '"');

                }).fail(function (error) {

                    Logger.error('CustomerServiceController: login: Failed to log in: error:', error);

                });

            };

        }]);
});